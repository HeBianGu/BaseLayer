<?xml version="1.0" encoding="utf-8"?>
<DirectedGraph xmlns="http://schemas.microsoft.com/vs/2009/dgml">
  <Nodes>
    <Node Id="79bdec34-6f3e-4c66-b444-40683126dcd71" Bounds="268.561734822591,-243.569886102927,3013.19333333333,391" Label="C#数学计算包 Math.NET&#xD;&#xA;&#xD;&#xA;Math.NET的目标是为提供一款自身包含清晰框架的符号运算和数学运算/科学运算，它是C#开发的开源类库。Math.NET含了一个支持线性代数的解析器，分析复杂微分，解方程等等功能。这个项目大部分采用的是MIT/X11开源软件协议，部份采用的是GPL 或 LGPL协议。&#xD;&#xA;&#xD;&#xA;Math.NET包含下列几个模块：&#xD;&#xA;&#xD;&#xA;Math.NET Numerics &#xD;&#xA;这个是Math.NET工程的数值计算部分，其目的是针对科学计算领域， 工程和日常应用，提供一些方法和算法。涵盖的领域包括特殊函数（special functions这个不太确定怎么翻译），线性代数，概率模型，随机数，插值，积分变换等等。自由软件，开源，基于MIT/X11 License, Math.NET Numerics v2.3.0于近期发布，支持Windows Phone 8和矩阵、向量切割。它还包含一个针对F#扩展的可移动版本，同样位于主发布包内。此外，发布包内的F#扩展现在使用F# 3.0，其最新版本完全专注于向量，并支持线性代数中的瘦QR分解（thin QR decomposition）。&#xD;&#xA;&#xD;&#xA;该最新版本还为所有连续或离散分布提供了一致的静态抽样方法，为F#中的随机数和分布提供了更好的可用性。它还为原生的线性代数提供程序更新了Intel数学内核库（MKL）。 Math.NET Numerics是针对.NET、Silverlight和Mono的开源数值计算库，是Math.NET项目的一部分。MathNet.Numerics和MathNet.Numerics.FSharp库现在都可以通过NuGet下载 &#xD;&#xA;Math.NET Iridium &#xD;&#xA;Iridium 是Math.NET Numerics的前身，它会尽快的被Numerics所取代。自由软件， 开源，基于LGPL授权 &#xD;&#xA;Math.NET LinqAlegebra &#xD;&#xA;LinqAlgebra（以前被称为Palladium）提供了一些基于纯Linq表达式顶层的元素，可以应用于通用的代数计算系统，包括自动简化，区分和数学标记语言 输入/输出（此处翻译不甚准确，毕竟俺们不是数学科班毕业呀） &#xD;&#xA;自由软件， 开源，基于LGPL授权 &#xD;&#xA;Math.NET Neodyma &#xD;&#xA;提供了一个用于数字信号处理的工具箱(DSP) &#xD;&#xA;自由软件， 开源，基于LGPL授权 ，https://github.com/mathnet/mathnet-numerics &#xD;&#xA;Math.NET Yttrium &#xD;&#xA;Yttrium 是一个实验性的计算代数结构，应用于形式上是硬件工程和数字信息的一些想法和概念，从一个不同的、全新的角度来看抽象数学和代数。用专业的图表来表现（代替了树）整个系统，而不单单是表达式。 &#xD;&#xA;由软件， 开源，基于GPL授权 &#xD;&#xA;Math.NET Classic &#xD;&#xA;一 个经典的利用树来表达的代数计算系统工具（和Maple，Mathematica相似，当然没他们那么给力）。其目标是提供一个延展框架来实现对代数表达 式的符号控制。并且，基础解析器能够把简单表达式解析成符号树或翻译成数学程序。基本上，在2003年中期的时候，他就是整个的“旧”的Math.net工程，除非我计划（这个工程的发起者）“复活”它并开始继续这些工作。&#xD;&#xA;&#xD;&#xA;官方网站：http://www.mathdotnet.com/" UseManualLocation="True" />
    <Node Id="80cd461f-71e1-4970-a934-c3a040ceb9861" Bounds="1497.63837779719,251.659232897802,1220.67666666667,1305.4" Label="C#中使用mathnet学习笔记(二) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;在C#中使用mathnet，需要利用using引入相关类&#xD;&#xA;&#xD;&#xA;矩阵运算的相关类：&#xD;&#xA;&#xD;&#xA;using MathNet.Numerics.LinearAlgebra.Double;&#xD;&#xA;&#xD;&#xA;using MathNet.Numerics.LinearAlgebra.Generic;&#xD;&#xA;1.矩阵定义和初始化&#xD;&#xA;&#xD;&#xA;       常用矩阵初始化函数：&#xD;&#xA;&#xD;&#xA;        var matrix2 = new DenseMatrix(3);  //3维方阵&#xD;&#xA;&#xD;&#xA;        var matrix3 = new DenseMatrix(2, 3); //2×3矩阵&#xD;&#xA;&#xD;&#xA;         var matrix4 = new DenseMatrix(2, 3, 3.0); //2×3矩阵，所有值为3.0&#xD;&#xA;&#xD;&#xA;         var matrixI = DenseMatrix.Identity(5); //5维单位矩阵&#xD;&#xA;&#xD;&#xA;       矩阵操作和C#中的数组操作一致，matrix2[m,n]取其m行n列上的值或对其赋值&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;         MathNet中重载了.ToString()函数，可以直接用matrix.ToString()输出整个数组，大大方便了调试和保存数据。&#xD;&#xA;&#xD;&#xA;      也可以利用C#中的double[,]直接创建&#xD;&#xA;&#xD;&#xA;         double[,] d_matrix = new double[2,3];&#xD;&#xA;&#xD;&#xA;  var matrix2 = new DenseMatrix(d_matrix); //2×3矩阵&#xD;&#xA;&#xD;&#xA;        小记：我曾做过测试，将double[,]先转成Math矩阵，然后进行矩阵运算，再利用matrix2.ToArray()将Math矩阵转换成double[,]，其运算时间和直接利用C#编写的矩阵运算相差很小。&#xD;&#xA;&#xD;&#xA; 但如果是利用for循环将double数组的数值赋值给Math矩阵进行矩阵运算，然后再利用for循环将Math矩阵赋值给某个double[，]数组，其运算时间可以减少1/3。在开发效率和运算效率上，使用的时候可以根据需要进行取舍。&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;2.矩阵操作&#xD;&#xA;&#xD;&#xA;     矩阵操作最常用的莫过于从一个矩阵中取值&#xD;&#xA;&#xD;&#xA;            var submatrix = matrix.SubMatrix(2, 2, 3, 3); //取从第二行开始的2行，第三列开始的三列 子矩阵&#xD;&#xA;&#xD;&#xA;            var row = matrix.Row(5, 3, 4); //取从第5行第3列开始的4个行元素&#xD;&#xA;&#xD;&#xA;            var column = matrix.Column(2, 6, 3); //取从第2列第6行开始的3个列元素&#xD;&#xA;&#xD;&#xA;             matrix.ColumnEnumerator(2, 4) //取从第2列开始的4列&#xD;&#xA;&#xD;&#xA;             matrix.RowEnumerator(4, 3)//取从第4行开始的3行&#xD;&#xA;&#xD;&#xA;            matrix.ToRowWiseArray()/matrix.ToColumnWiseArray() //矩阵变为行向量或者列向量&#xD;&#xA;&#xD;&#xA;           matrix.Diagonal()//取矩阵的对角线元素向量&#xD;&#xA;&#xD;&#xA;     向矩阵中插值&#xD;&#xA;&#xD;&#xA;          var result = matrix.InsertColumn(3, vector)/matrix.InsertRow(3, vector);//将向量vector插入到指定的行/列，原有的行列顺延&#xD;&#xA;&#xD;&#xA;           matrix.SetColumn(2, (Vector)vector);/matrix.SetRow(3, (double[])vector);  //用vector替换指定的行/列&#xD;&#xA;&#xD;&#xA;     matrix.SetSubMatrix(1, 3, 1, 3, DenseMatrix.Identity(3)); //用矩阵替换指定位置的块矩阵&#xD;&#xA;&#xD;&#xA;          matrix.SetDiagonal(new[] { 5.0, 4.0, 3.0, 2.0, 1.0 });  //替换矩阵的对角线元素&#xD;&#xA;&#xD;&#xA;          matrixA.Append(matrixB,result)/matrixA.Stack(matrixB,result) //将matrixB扩展到matrixA的右方/上方，将结果保存在result中&#xD;&#xA;&#xD;&#xA;    矩阵转换：   &#xD;&#xA;&#xD;&#xA;           var permutations = new Permutation(new[] { 0, 1, 3, 2, 4 });&#xD;&#xA;&#xD;&#xA;     matrix.PermuteRows(permutations);   //互换矩阵的3，4行&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;            permutations = new Permutation(new[] { 1, 0, 4, 3, 2 });&#xD;&#xA;&#xD;&#xA;            matrix.PermuteColumns(permutations);  //互换矩阵的1，2列，3，5列。&#xD;&#xA;&#xD;&#xA;            可以看出，互换是由Permutation中的数字序号决定的。&#xD;&#xA;" UseManualLocation="True" />
    <Node Id="d6480f21-cce7-4d34-8c83-c3af23e0a06b1" Bounds="494.327011108398,177.430213897073,938.913333333333,863.44" Label="C#使用mathnet学习笔记(三) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;1.矩阵运算&#xD;&#xA;&#xD;&#xA;            matrixA = 3.0 * matrixB    //数乘&#xD;&#xA;&#xD;&#xA;            matrixA = vector * matrixB  /matrixA =  matrixB * vector  //向量乘&#xD;&#xA;&#xD;&#xA;            matrixC = matrixA + / - / * matrixB   //矩阵加、减、乘&#xD;&#xA;&#xD;&#xA;            resultM = (DenseMatrix)matrixA.PointwiseDivide(matrixB); //点乘&#xD;&#xA;&#xD;&#xA;           上述所有运算符都有对应的函数，也可是利用函数进行运算，如“+”可以写成   matrixC = (DenseMatrix)matrixA.Add(matrixB);或者matrixA.Add(matrixB, matrixC);&#xD;&#xA;&#xD;&#xA;            matrixB = matrixA.Inverse()/Transpose()  //求逆和转置&#xD;&#xA;&#xD;&#xA;2.求解线性方程组&#xD;&#xA;&#xD;&#xA;            对于一阶线性方程组&#xD;&#xA;&#xD;&#xA;      5*x + 2*y - 4*z = -7&#xD;&#xA;&#xD;&#xA;             3*x - 7*y + 6*z = 38&#xD;&#xA;&#xD;&#xA;             4*x + 1*y + 5*z = 43&#xD;&#xA;&#xD;&#xA;             可以如下求解：&#xD;&#xA;&#xD;&#xA;              var matrixA = new DenseMatrix(new[,] { { 5.00, 2.00, -4.00 }, { 3.00, -7.00, 6.00 }, { 4.00, 1.00, 5.00 } });&#xD;&#xA;&#xD;&#xA;              var vectorB = new DenseVector(new[] { -7.0, 38.0, 43.0 });&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;               var resultX = matrixA.LU().Solve(vectorB);&#xD;&#xA;&#xD;&#xA; 或者&#xD;&#xA;&#xD;&#xA;              resultX = matrixA.QR().Solve(vectorB);&#xD;&#xA;&#xD;&#xA; 或者&#xD;&#xA;&#xD;&#xA;              matrixA.Svd(true).Solve(vectorB, resultX);&#xD;&#xA;&#xD;&#xA; 或者&#xD;&#xA;&#xD;&#xA;              matrixA.GramSchmidt().Solve(vectorB, resultX);&#xD;&#xA;&#xD;&#xA;3.矩阵秩、行列式、trace和范数&#xD;&#xA;&#xD;&#xA;         matrix.Determinant()/Rank()/ConditionNumber()/Trace()   //行列式/秩/条件数/trace&#xD;&#xA;&#xD;&#xA;        matrix.L1Norm()/L2Norm()/FrobeniusNorm()/InfinityNorm()   //范数&#xD;&#xA;" UseManualLocation="True" />
  </Nodes>
  <Links>
    <Link Source="79bdec34-6f3e-4c66-b444-40683126dcd71" Target="80cd461f-71e1-4970-a934-c3a040ceb9861" Bounds="1843.47424924576,147.430114746094,33.4530551954665,95.7329144997409" />
    <Link Source="79bdec34-6f3e-4c66-b444-40683126dcd71" Target="d6480f21-cce7-4d34-8c83-c3af23e0a06b1" Bounds="1440.23389163454,147.430113897073,93.5688993277083,75.7915665545284" />
  </Links>
  <Properties>
    <Property Id="Bounds" DataType="System.Windows.Rect" />
    <Property Id="Label" Label="标签" Description="可批注对象的可显示标签" DataType="System.String" />
    <Property Id="UseManualLocation" DataType="System.Boolean" />
  </Properties>
</DirectedGraph>