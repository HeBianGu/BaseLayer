#region 程序集 mscorlib.dll, v4.0.0.0
// C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\mscorlib.dll
#endregion

using System;
using System.Reflection;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices.ComTypes;
using System.Security;
using System.Threading;

namespace System.Runtime.InteropServices
{
    // 摘要: 
    //     提供了一个方法集，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在与非托管代码交互时使用的其他杂项方法。
    public static class Marshal
    {
        // 摘要: 
        //     表示系统上的默认字符大小；Unicode 系统上默认值为 2，ANSI 系统上默认值为 1。此字段为只读。
        public static readonly int SystemDefaultCharSize;
        //
        // 摘要: 
        //     表示用于当前操作系统的双字节字符集 (DBCS) 的最大大小（以字节为单位）。此字段为只读。
        public static readonly int SystemMaxDBCSCharSize;

        // 摘要: 
        //     递增指定接口上的引用计数。
        //
        // 参数: 
        //   pUnk:
        //     要递增的接口引用计数。
        //
        // 返回结果: 
        //     pUnk 参数上的引用计数的新值。
        [SecurityCritical]
        public static int AddRef(IntPtr pUnk);
        //
        // 摘要: 
        //     从 COM 任务内存分配器分配指定大小的内存块。
        //
        // 参数: 
        //   cb:
        //     要分配的内存块的大小。
        //
        // 返回结果: 
        //     整数，表示分配的内存块的地址。此内存必须用 System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
        //     来释放。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     内存不足，无法满足请求。
        [SecurityCritical]
        public static IntPtr AllocCoTaskMem(int cb);
        //
        // 摘要: 
        //     通过使用指定的字节数，从进程的非托管内存中分配内存。
        //
        // 参数: 
        //   cb:
        //     内存中的所需字节数。
        //
        // 返回结果: 
        //     指向新分配的内存的指针。必须使用 System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
        //     方法释放此内存。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     内存不足，无法满足请求。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        [SecurityCritical]
        public static IntPtr AllocHGlobal(int cb);
        //
        // 摘要: 
        //     通过使用指向指定字节数的指针，从进程的非托管内存中分配内存。
        //
        // 参数: 
        //   cb:
        //     内存中的所需字节数。
        //
        // 返回结果: 
        //     指向新分配的内存的指针。必须使用 System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
        //     方法释放此内存。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     内存不足，无法满足请求。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        [SecurityCritical]
        public static IntPtr AllocHGlobal(IntPtr cb);
        //
        // 摘要: 
        //     指示是否可以清除任何上下文中的运行时可调用包装 (RCW)。
        //
        // 返回结果: 
        //     如果存在任何可清除的 RCW，则为 true；否则为 false。
        [SecurityCritical]
        public static bool AreComObjectsAvailableForCleanup();
        //
        // 摘要: 
        //     获取由指定的名字对象标识的接口指针。
        //
        // 参数: 
        //   monikerName:
        //     与所需接口指针相对应的名字对象。
        //
        // 返回结果: 
        //     一个对象，它包含对由 monikerName 参数标识的接口指针的引用。名字对象是一个名称，在此情况下，名字对象由接口定义。
        //
        // 异常: 
        //   System.Runtime.InteropServices.COMException:
        //     非托管 BindToMoniker 方法返回一个无法识别的 HRESULT。
        [SecurityCritical]
        public static object BindToMoniker(string monikerName);
        //
        // 摘要: 
        //     更改对象的 COM Callable Wrapper (CCW) 句柄的强度。
        //
        // 参数: 
        //   otp:
        //     一个对象，其 CCW 包含带有引用计数的句柄。如果 CCW 上的引用计数大于零，则该句柄是强的；否则它是弱的。
        //
        //   fIsWeak:
        //     为 true 时，忽略 otp 的引用计数，将其句柄强度改为弱；为 false 时，重置要进行引用计数的 otp 上的句柄强度。
        [SecurityCritical]
        public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
        //
        // 摘要: 
        //     通知运行时清理在当前上下文中分配的所有运行时可调用包装 (RCW)。
        [SecurityCritical]
        public static void CleanupUnusedObjectsInCurrentContext();
        //
        // 摘要: 
        //     将一维的托管 8 位无符号整数数组中的数据复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     source、startIndex、destination 或 length 为 null。
        [SecurityCritical]
        public static void Copy(byte[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从一维的托管字符数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     startIndex、destination 或 length 为 null。
        [SecurityCritical]
        public static void Copy(char[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从一维的托管双精度浮点数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     source、startIndex、destination 或 length 为 null。
        [SecurityCritical]
        public static void Copy(double[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从一维的托管单精度浮点数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     source、startIndex、destination 或 length 为 null。
        [SecurityCritical]
        public static void Copy(float[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从一维的托管 32 位带符号整数数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(int[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管 8 位无符号整数数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, byte[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管字符数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, char[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管双精度浮点数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, double[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管单精度浮点数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, float[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管 32 位带符号整数数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, int[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管 System.IntPtr 数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     数组中应作为复制起始处的索引（其起始值为零）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管 64 位带符号整数数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, long[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从非托管内存指针复制到托管 16 位带符号整数数组。
        //
        // 参数: 
        //   source:
        //     内存指针，从中进行复制。
        //
        //   destination:
        //     要复制到的数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr source, short[] destination, int startIndex, int length);
        //
        // 摘要: 
        //     将数据从一维托管 System.IntPtr 数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     数组中应作为复制起始处的索引（其起始值为零）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     source、destination、startIndex 或 length 为 null。
        [SecurityCritical]
        public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从一维的托管 64 位带符号整数数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     source、startIndex、destination 或 length 为 null。
        [SecurityCritical]
        public static void Copy(long[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     将数据从一维的托管 16 位带符号整数数组复制到非托管内存指针。
        //
        // 参数: 
        //   source:
        //     从中进行复制的一维数组。
        //
        //   startIndex:
        //     源数组中复制起始位置的索引（从零开始）。
        //
        //   destination:
        //     要复制到的内存指针。
        //
        //   length:
        //     要复制的数组元素的数目。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     startIndex 和 length 无效。
        //
        //   System.ArgumentNullException:
        //     source、startIndex、destination 或 length 为 null。
        [SecurityCritical]
        public static void Copy(short[] source, int startIndex, IntPtr destination, int length);
        //
        // 摘要: 
        //     聚合托管对象和指定的 COM 对象。
        //
        // 参数: 
        //   pOuter:
        //     外部 IUnknown 指针。
        //
        //   o:
        //     要聚合的对象。
        //
        // 返回结果: 
        //     托管对象的内部 IUnknown 指针。
        [SecurityCritical]
        public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
        //
        // 摘要: 
        //     在指定类型的对象中包装指定的 COM 对象。
        //
        // 参数: 
        //   o:
        //     要包装的对象。
        //
        //   t:
        //     要创建的包装的类型。
        //
        // 返回结果: 
        //     新包装的对象，该对象是所需类型的实例。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 必须从 __ComObject 派生。
        //
        //   System.ArgumentNullException:
        //     t 参数为 null。
        //
        //   System.InvalidCastException:
        //     o 无法转换为目标类型，因为它不支持所有所需的接口。
        [SecurityCritical]
        public static object CreateWrapperOfType(object o, Type t);
        //
        // 摘要: 
        //     释放指定的非托管内存块所指向的所有子结构。
        //
        // 参数: 
        //   ptr:
        //     指向非托管内存块的指针。
        //
        //   structuretype:
        //     格式化类的类型。该类型提供删除 ptr 参数指向的缓冲区时必需的布局信息。
        //
        // 异常: 
        //   System.ArgumentException:
        //     structureType 具有自动布局。但请使用连续或显式布局。
        [ComVisible(true)]
        [SecurityCritical]
        public static void DestroyStructure(IntPtr ptr, Type structuretype);
        //
        // 摘要: 
        //     通过将 Runtime Callable Wrapper (RCW) 的引用计数设置为 0，释放对它的所有引用。
        //
        // 参数: 
        //   o:
        //     要释放的 RCW。
        //
        // 返回结果: 
        //     与 o 参数关联的 RCW 的引用计数的新值，如果释放成功，则为 0（零）。
        //
        // 异常: 
        //   System.ArgumentException:
        //     o 不是一个有效的 COM 对象。
        //
        //   System.ArgumentNullException:
        //     o 为 null。
        [SecurityCritical]
        public static int FinalReleaseComObject(object o);
        //
        // 摘要: 
        //     使用 COM SysFreeString 函数释放 BSTR。
        //
        // 参数: 
        //   ptr:
        //     要释放的 BSTR 的地址。
        [SecurityCritical]
        public static void FreeBSTR(IntPtr ptr);
        //
        // 摘要: 
        //     释放由非托管 COM 任务内存分配器分配的内存块。
        //
        // 参数: 
        //   ptr:
        //     要释放的内存的地址。
        [SecurityCritical]
        public static void FreeCoTaskMem(IntPtr ptr);
        //
        // 摘要: 
        //     释放以前从进程的非托管内存中分配的内存。
        //
        // 参数: 
        //   hglobal:
        //     由对 System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr) 的原始匹配调用返回的句柄。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static void FreeHGlobal(IntPtr hglobal);
        //
        // 摘要: 
        //     返回指定类型的全局唯一标识符 (GUID)，或使用类型库导出程序 (Tlbexp.exe) 所用的算法生成 GUID。
        //
        // 参数: 
        //   type:
        //     要为其生成 GUID 的类型。
        //
        // 返回结果: 
        //     指定类型的标识符。
        [SecurityCritical]
        public static Guid GenerateGuidForType(Type type);
        //
        // 摘要: 
        //     返回指定类型的编程标识符 (ProgID)。
        //
        // 参数: 
        //   type:
        //     要获取其 ProgID 的类型。
        //
        // 返回结果: 
        //     指定类型的 ProgID。
        //
        // 异常: 
        //   System.ArgumentException:
        //     参数 type 类无法由 COM 创建。该类必须是公共的，必须具有公共的默认构造函数，而且必须是 COM 可见的。
        //
        //   System.ArgumentNullException:
        //     type 参数为 null。
        [SecurityCritical]
        public static string GenerateProgIdForType(Type type);
        //
        // 摘要: 
        //     从运行对象表 (ROT) 获取指定对象的运行实例。
        //
        // 参数: 
        //   progID:
        //     所请求的对象的编程标识符 (ProgID)。
        //
        // 返回结果: 
        //     所请求的对象；否则为 null。可将此对象强制转换为它所支持的任何 COM 接口。
        //
        // 异常: 
        //   System.Runtime.InteropServices.COMException:
        //     找不到该对象。
        [SecurityCritical]
        public static object GetActiveObject(string progID);
        //
        // 摘要: 
        //     返回一个指向 IUnknown 接口的指针，该指针表示指定对象上的指定接口。默认情况下，启用自定义查询接口访问。
        //
        // 参数: 
        //   o:
        //     提供接口的对象。
        //
        //   T:
        //     所请求的接口的类型。
        //
        // 返回结果: 
        //     表示对象的指定接口的接口指针。
        //
        // 异常: 
        //   System.ArgumentException:
        //     T 参数不是接口。- 或 -该类型对 COM 不可见。- 或 -T 参数是泛型类型。
        //
        //   System.InvalidCastException:
        //     o 参数不支持请求的接口。
        //
        //   System.ArgumentNullException:
        //     o 参数为 null。- 或 -T 参数为 null。
        [SecurityCritical]
        public static IntPtr GetComInterfaceForObject(object o, Type T);
        //
        // 摘要: 
        //     返回一个指向 IUnknown 接口的指针，该指针表示指定对象上的指定接口。自定义查询接口访问由指定的自定义模式控制。
        //
        // 参数: 
        //   o:
        //     提供接口的对象。
        //
        //   T:
        //     所请求的接口的类型。
        //
        //   mode:
        //     枚举值之一，指示是否应用由 System.Runtime.InteropServices.ICustomQueryInterface 提供的 IUnknown::
        //     QueryInterface 自定义。
        //
        // 返回结果: 
        //     表示对象的接口的接口指针。
        //
        // 异常: 
        //   System.ArgumentException:
        //     T 参数不是接口。- 或 -该类型对 COM 不可见。- 或 -T 参数是泛型类型。
        //
        //   System.InvalidCastException:
        //     对象 o 不支持请求的接口。
        //
        //   System.ArgumentNullException:
        //     o 参数为 null。- 或 -T 参数为 null。
        [SecurityCritical]
        public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
        //
        // 摘要: 
        //     返回一个接口指针，该指针表示对象的指定接口（如果调用方与对象在同一上下文中）。
        //
        // 参数: 
        //   o:
        //     提供接口的对象。
        //
        //   t:
        //     所请求的接口的类型。
        //
        // 返回结果: 
        //     由 t 指定的接口指针，该指针表示指定对象的接口，如果调用方与指定对象不在同一上下文中，则为 null。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 不是一个接口。- 或 -该类型对 COM 不可见。
        //
        //   System.InvalidCastException:
        //     o 不支持请求的接口。
        //
        //   System.ArgumentNullException:
        //     o 为 null。- 或 -t 为 null。
        [SecurityCritical]
        public static IntPtr GetComInterfaceForObjectInContext(object o, Type t);
        //
        // 摘要: 
        //     从指定的 COM 对象检索指定键所引用的数据。
        //
        // 参数: 
        //   obj:
        //     包含所需数据的 COM 对象。
        //
        //   key:
        //     要从中检索数据的 obj 的内部哈希表中的键。
        //
        // 返回结果: 
        //     obj 参数的内部哈希表中 key 参数所表示的数据。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     obj 为 null。- 或 -key 为 null。
        //
        //   System.ArgumentException:
        //     obj 不是一个 COM 对象。
        [SecurityCritical]
        public static object GetComObjectData(object obj, object key);
        //
        // 摘要: 
        //     检索指定的 System.Reflection.MemberInfo 类型向 COM 公开时该类型的虚函数表（v 表或 VTBL）槽。
        //
        // 参数: 
        //   m:
        //     一个表示接口方法的对象。
        //
        // 返回结果: 
        //     向 COM 公开它时的 VTBL 槽 m 标识符。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     m 参数为 null。
        //
        //   System.ArgumentException:
        //     m 参数不是 System.Reflection.MemberInfo 对象。- 或 -参数 m 不是接口方法。
        [SecurityCritical]
        public static int GetComSlotForMethodInfo(MemberInfo m);
        //
        // 摘要: 
        //     将非托管函数指针转换为委托。
        //
        // 参数: 
        //   ptr:
        //     要转换的非托管函数指针。
        //
        //   t:
        //     要返回的委托的类型。
        //
        // 返回结果: 
        //     委托实例，可强制转换为适当的委托类型。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 参数不是委托或泛型。
        //
        //   System.ArgumentNullException:
        //     ptr 参数为 null。- 或 -t 参数为 null。
        [SecurityCritical]
        public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
        //
        // 摘要: 
        //     检索在向 COM 公开时某类型的虚函数表（v 表或 VTBL）中的最后一个槽。
        //
        // 参数: 
        //   t:
        //     表示接口或类的类型。
        //
        // 返回结果: 
        //     向 COM 公开时接口的最后一个 VTBL 槽。如果 t 参数是类，则返回的 VTBL 槽是从该类生成的接口中的最后一个槽。
        [SecurityCritical]
        public static int GetEndComSlot(Type t);
        //
        // 摘要: 
        //     检索标识所发生异常的类型的代码。
        //
        // 返回结果: 
        //     异常的类型。
        [SecurityCritical]
        public static int GetExceptionCode();
        //
        // 摘要: 
        //     将指定的 HRESULT 错误代码转换为对应的 System.Exception 对象。
        //
        // 参数: 
        //   errorCode:
        //     要转换的 HRESULT。
        //
        // 返回结果: 
        //     一个对象，表示转换后的 HRESULT。
        [SecurityCritical]
        public static Exception GetExceptionForHR(int errorCode);
        //
        // 摘要: 
        //     通过传入异常对象的 IErrorInfo 接口的附加错误消息，将指定的 HRESULT 错误代码转换为对应的 System.Exception 对象。
        //
        // 参数: 
        //   errorCode:
        //     要转换的 HRESULT。
        //
        //   errorInfo:
        //     指向 IErrorInfo 接口的指针，该接口提供有关错误的更多信息。您可以指定 IntPtr(0) 以使用当前 IErrorInfo 接口，或者指定
        //     IntPtr(-1) 以忽略当前 IErrorInfo 接口，并仅从错误代码构造异常。
        //
        // 返回结果: 
        //     一个对象，表示转换后的 HRESULT 以及从 errorInfo 获取的信息。
        [SecurityCritical]
        public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
        //
        // 摘要: 
        //     检索与计算机无关的异常描述以及有关异常发生时线程的状态信息。
        //
        // 返回结果: 
        //     一个指向 EXCEPTION_POINTERS 结构的指针。
        [ComVisible(true)]
        [SecurityCritical]
        public static IntPtr GetExceptionPointers();
        //
        // 摘要: 
        //     将委托转换为可从非托管代码调用的函数指针。
        //
        // 参数: 
        //   d:
        //     要传递给非托管代码的委托。
        //
        // 返回结果: 
        //     一个可传递给非托管代码的值，非托管代码使用该值来调用基础托管委托。
        //
        // 异常: 
        //   System.ArgumentException:
        //     d 参数是泛型类型。
        //
        //   System.ArgumentNullException:
        //     d 参数为 null。
        [SecurityCritical]
        public static IntPtr GetFunctionPointerForDelegate(Delegate d);
        //
        // 摘要: 
        //     返回指定模块的实例句柄 (HINSTANCE)。
        //
        // 参数: 
        //   m:
        //     具有所需 HINSTANCE 的模块。
        //
        // 返回结果: 
        //     m 的 HINSTANCE；如果该模块没有 HINSTANCE，则为 -1。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     m 参数为 null。
        [SecurityCritical]
        public static IntPtr GetHINSTANCE(Module m);
        //
        // 摘要: 
        //     将指定异常转换为 HRESULT。
        //
        // 参数: 
        //   e:
        //     要转换为 HRESULT 的异常。
        //
        // 返回结果: 
        //     映射到所提供的异常的 HRESULT。
        [SecurityCritical]
        public static int GetHRForException(Exception e);
        //
        // 摘要: 
        //     返回 HRESULT，它对应于使用 System.Runtime.InteropServices.Marshal 执行的 Win32 代码引起的最后一个错误。
        //
        // 返回结果: 
        //     对应于最后一个 Win32 错误代码的 HRESULT。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static int GetHRForLastWin32Error();
        //
        // 摘要: 
        //     从托管对象返回一个 IDispatch 接口。
        //
        // 参数: 
        //   o:
        //     其 IDispatch 接口被请求的对象。
        //
        // 返回结果: 
        //     o 参数的 IDispatch 指针。
        //
        // 异常: 
        //   System.InvalidCastException:
        //     o 不支持请求的接口。
        [SecurityCritical]
        public static IntPtr GetIDispatchForObject(object o);
        //
        // 摘要: 
        //     如果调用方与托管对象在同一上下文中，则从该对象返回一个 IDispatch 接口指针。
        //
        // 参数: 
        //   o:
        //     其 IDispatch 接口被请求的对象。
        //
        // 返回结果: 
        //     指定对象的 IDispatch 接口指针；如果调用方与指定对象不在同一上下文中，则为 null。
        //
        // 异常: 
        //   System.InvalidCastException:
        //     o 不支持请求的接口。
        //
        //   System.ArgumentNullException:
        //     o 为 null。
        [SecurityCritical]
        public static IntPtr GetIDispatchForObjectInContext(object o);
        //
        // 摘要: 
        //     从托管类型返回一个 System.Runtime.InteropServices.ComTypes.ITypeInfo 接口。
        //
        // 参数: 
        //   t:
        //     正在请求其 ITypeInfo 接口的类型。
        //
        // 返回结果: 
        //     指向 t 参数的 ITypeInfo 接口的指针。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 不是 COM 可见的类型。
        //
        //   System.Runtime.InteropServices.COMException:
        //     为包含该类型的程序集注册了类型库，但无法找到类型定义。
        [SecurityCritical]
        public static IntPtr GetITypeInfoForType(Type t);
        //
        // 摘要: 
        //     从托管对象返回 IUnknown 接口。
        //
        // 参数: 
        //   o:
        //     其 IUnknown 接口被请求的对象。
        //
        // 返回结果: 
        //     o 参数的 IUnknown 指针。
        [SecurityCritical]
        public static IntPtr GetIUnknownForObject(object o);
        //
        // 摘要: 
        //     如果调用方与托管对象在同一上下文中，则从该对象返回一个 IUnknown 接口。
        //
        // 参数: 
        //   o:
        //     其 IUnknown 接口被请求的对象。
        //
        // 返回结果: 
        //     指定对象的 IUnknown 指针；如果调用方与指定对象不在同一上下文中，则为 null。
        [SecurityCritical]
        public static IntPtr GetIUnknownForObjectInContext(object o);
        //
        // 摘要: 
        //     返回由上一个非托管函数返回的错误代码，该函数是使用设置了 System.Runtime.InteropServices.DllImportAttribute.SetLastError
        //     标志的平台调用来调用的。
        //
        // 返回结果: 
        //     通过调用 Win32 SetLastError 函数设置的最后一个错误代码。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static int GetLastWin32Error();
        //
        // 摘要: 
        //     获取指向运行时生成的函数的指针，该函数封送从托管代码到非托管代码的调用。
        //
        // 参数: 
        //   pfnMethodToWrap:
        //     指向要封送的方法的指针。
        //
        //   pbSignature:
        //     指向方法签名的指针。
        //
        //   cbSignature:
        //     pbSignature 中的字节数。
        //
        // 返回结果: 
        //     指向一个函数的指针，该函数将封送从 pfnMethodToWrap 参数到非托管代码的调用。
        [Obsolete("The GetManagedThunkForUnmanagedMethodPtr method has been deprecated and will be removed in a future release.", false)]
        [SecurityCritical]
        public static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
        //
        // 摘要: 
        //     检索指定的虚函数表（v 表或 VTBL）槽的 System.Reflection.MemberInfo 对象。
        //
        // 参数: 
        //   t:
        //     针对其检索 System.Reflection.MemberInfo 的类型。
        //
        //   slot:
        //     VTBL 槽。
        //
        //   memberType:
        //     在成功返回时，为指定成员类型的枚举值之一。
        //
        // 返回结果: 
        //     表示指定 VTBL 槽上成员的对象。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 在 COM 中不可见。
        [SecurityCritical]
        public static MemberInfo GetMethodInfoForComSlot(Type t, int slot, ref ComMemberType memberType);
        //
        // 摘要: 
        //     将对象转换为 COM VARIANT。
        //
        // 参数: 
        //   obj:
        //     为其获取 COM VARIANT 的对象。
        //
        //   pDstNativeVariant:
        //     一个指针，接收对应于 obj 参数的 VARIANT。
        //
        // 异常: 
        //   System.ArgumentException:
        //     obj 参数是泛型类型。
        [SecurityCritical]
        public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
        //
        // 摘要: 
        //     返回一个类型实例，该实例通过指向 COM 对象的 IUnknown 接口的指针表示该对象。
        //
        // 参数: 
        //   pUnk:
        //     指向 IUnknown 接口的指针。
        //
        // 返回结果: 
        //     一个对象，表示指定的非托管 COM 对象。
        [SecurityCritical]
        public static object GetObjectForIUnknown(IntPtr pUnk);
        //
        // 摘要: 
        //     将 COM VARIANT 转换为对象。
        //
        // 参数: 
        //   pSrcNativeVariant:
        //     指向 COM VARIANT 的指针。
        //
        // 返回结果: 
        //     一个对象，对应于 pSrcNativeVariant 参数。
        //
        // 异常: 
        //   System.Runtime.InteropServices.InvalidOleVariantTypeException:
        //     pSrcNativeVariant 不是有效的 VARIANT 类型。
        //
        //   System.NotSupportedException:
        //     pSrcNativeVariant 包含不受支持的类型。
        [SecurityCritical]
        public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
        //
        // 摘要: 
        //     将 COM VARIANTs 数组转换为对象数组。
        //
        // 参数: 
        //   aSrcNativeVariant:
        //     指向 COM VARIANT 数组中第一个元素的指针。
        //
        //   cVars:
        //     aSrcNativeVariant 中的 COM VARIANT 的计数。
        //
        // 返回结果: 
        //     一个对象数组，对应于 aSrcNativeVariant。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     cVars 是一个负数。
        [SecurityCritical]
        public static object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
        //
        // 摘要: 
        //     获取虚函数表（v 表或 VTBL）中第一个包含用户定义的方法的槽。
        //
        // 参数: 
        //   t:
        //     表示接口的类型。
        //
        // 返回结果: 
        //     第一个包含用户定义的方法的 VTBL 槽。如果接口基于 IUnknown，则第一个槽为 3；如果接口基于 IDispatch，则为 7。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 在 COM 中不可见。
        [SecurityCritical]
        public static int GetStartComSlot(Type t);
        //
        // 摘要: 
        //     将纤程 Cookie 转换为相应的 System.Threading.Thread 实例。
        //
        // 参数: 
        //   cookie:
        //     表示纤程 Cookie 的整数。
        //
        // 返回结果: 
        //     对应于 cookie 参数的线程。
        //
        // 异常: 
        //   System.ArgumentException:
        //     cookie 参数为 0。
        [Obsolete("The GetThreadFromFiberCookie method has been deprecated.  Use the hosting API to perform this operation.", false)]
        [SecurityCritical]
        public static Thread GetThreadFromFiberCookie(int cookie);
        //
        // 摘要: 
        //     返回表示 COM 对象的指定类型的托管对象。
        //
        // 参数: 
        //   pUnk:
        //     指向非托管对象的 IUnknown 接口的指针。
        //
        //   t:
        //     请求的托管类的类型。
        //
        // 返回结果: 
        //     类的实例，与表示所请求的非托管 COM 对象的 System.Type 对象相对应。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 未用 System.Runtime.InteropServices.ComImportAttribute 进行属性化。
        [SecurityCritical]
        public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
        //
        // 摘要: 
        //     将非托管 ITypeInfo 对象转换为托管 System.Type 对象。
        //
        // 参数: 
        //   piTypeInfo:
        //     要封送的 ITypeInfo 接口。
        //
        // 返回结果: 
        //     表示非托管 ITypeInfo 对象的托管类型。
        [SecurityCritical]
        public static Type GetTypeForITypeInfo(IntPtr piTypeInfo);
        //
        // 摘要: 
        //     检索由 ITypeInfo 对象表示的类型的名称。
        //
        // 参数: 
        //   typeInfo:
        //     表示 ITypeInfo 指针的对象。
        //
        // 返回结果: 
        //     typeInfo 参数指向的类型的名称。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     typeInfo 参数为 null。
        [SecurityCritical]
        public static string GetTypeInfoName(ITypeInfo typeInfo);
        //
        // 摘要: 
        //     检索由 ITypeInfo 对象表示的类型的名称。
        //
        // 参数: 
        //   pTI:
        //     表示 ITypeInfo 指针的对象。
        //
        // 返回结果: 
        //     pTI 参数指向的类型的名称。
        [Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeInfoName(ITypeInfo pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", false)]
        [SecurityCritical]
        public static string GetTypeInfoName(UCOMITypeInfo pTI);
        //
        // 摘要: 
        //     检索类型库的库标识符 (LIBID)。
        //
        // 参数: 
        //   typelib:
        //     要检索其 LIBID 的类型库。
        //
        // 返回结果: 
        //     指定类型库的 LIBID。
        [SecurityCritical]
        public static Guid GetTypeLibGuid(ITypeLib typelib);
        //
        // 摘要: 
        //     检索类型库的库标识符 (LIBID)。
        //
        // 参数: 
        //   pTLB:
        //     要检索其 LIBID 的类型库。
        //
        // 返回结果: 
        //     pTLB 参数指向的类型库的 LIBID。
        [Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibGuid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", false)]
        [SecurityCritical]
        public static Guid GetTypeLibGuid(UCOMITypeLib pTLB);
        //
        // 摘要: 
        //     检索从指定程序集导出类型库时分配给该类型库的库标识符 (LIBID)。
        //
        // 参数: 
        //   asm:
        //     从其导出类型库的程序集。
        //
        // 返回结果: 
        //     从指定的程序集导出类型库时分配给该类型库的 LIBID。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     asm 为 null。
        [SecurityCritical]
        public static Guid GetTypeLibGuidForAssembly(Assembly asm);
        //
        // 摘要: 
        //     检索类型库的 LCID。
        //
        // 参数: 
        //   typelib:
        //     要检索其 LCID 的类型库。
        //
        // 返回结果: 
        //     typelib 参数指向的类型库的 LCID。
        [SecurityCritical]
        public static int GetTypeLibLcid(ITypeLib typelib);
        //
        // 摘要: 
        //     检索类型库的 LCID。
        //
        // 参数: 
        //   pTLB:
        //     要检索其 LCID 的类型库。
        //
        // 返回结果: 
        //     pTLB 参数指向的类型库的 LCID。
        [Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibLcid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", false)]
        [SecurityCritical]
        public static int GetTypeLibLcid(UCOMITypeLib pTLB);
        //
        // 摘要: 
        //     检索类型库的名称。
        //
        // 参数: 
        //   typelib:
        //     要检索其名称的类型库。
        //
        // 返回结果: 
        //     typelib 参数指向的类型库的名称。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     typelib 参数为 null。
        [SecurityCritical]
        public static string GetTypeLibName(ITypeLib typelib);
        //
        // 摘要: 
        //     检索类型库的名称。
        //
        // 参数: 
        //   pTLB:
        //     要检索其名称的类型库。
        //
        // 返回结果: 
        //     pTLB 参数指向的类型库的名称。
        [Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibName(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", false)]
        [SecurityCritical]
        public static string GetTypeLibName(UCOMITypeLib pTLB);
        //
        // 摘要: 
        //     检索将从指定程序集导出的类型库的版本号。
        //
        // 参数: 
        //   inputAssembly:
        //     托管程序集。
        //
        //   majorVersion:
        //     主要版本号。
        //
        //   minorVersion:
        //     次要版本号。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     inputAssembly 为 null。
        [SecurityCritical]
        public static void GetTypeLibVersionForAssembly(Assembly inputAssembly, out int majorVersion, out int minorVersion);
        //
        // 摘要: 
        //     为给定的 IUnknown 接口创建唯一的 Runtime Callable Wrapper (RCW) 对象。
        //
        // 参数: 
        //   unknown:
        //     指向 IUnknown 接口的托管指针。
        //
        // 返回结果: 
        //     指定的 IUnknown 接口的唯一 RCW。
        [SecurityCritical]
        public static object GetUniqueObjectForIUnknown(IntPtr unknown);
        //
        // 摘要: 
        //     获取指向运行时生成的函数的指针，该函数封送从非托管代码到托管代码的调用。
        //
        // 参数: 
        //   pfnMethodToWrap:
        //     指向要封送的方法的指针。
        //
        //   pbSignature:
        //     指向方法签名的指针。
        //
        //   cbSignature:
        //     pbSignature 中的字节数。
        //
        // 返回结果: 
        //     指向一个函数的指针，该函数将封送从 pfnMethodToWrap 到托管代码的调用。
        [Obsolete("The GetUnmanagedThunkForManagedMethodPtr method has been deprecated and will be removed in a future release.", false)]
        [SecurityCritical]
        public static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
        //
        // 摘要: 
        //     指示指定对象是否表示 COM 对象。
        //
        // 参数: 
        //   o:
        //     要检查的对象。
        //
        // 返回结果: 
        //     如果 o 参数是 COM 类型，则为 true；否则为 false。
        [SecuritySafeCritical]
        public static bool IsComObject(object o);
        //
        // 摘要: 
        //     指示类型对 COM 客户端是否可见。
        //
        // 参数: 
        //   t:
        //     要检查其 COM 可见性的类型。
        //
        // 返回结果: 
        //     如果该类型对 COM 是可见的，则为 true；否则为 false。
        [SecuritySafeCritical]
        public static bool IsTypeVisibleFromCom(Type t);
        //
        // 摘要: 
        //     计算在非托管内存中保存指定方法的参数所需要的字节数。
        //
        // 参数: 
        //   m:
        //     要检查的方法。
        //
        // 返回结果: 
        //     在非托管内存中表示方法参数所需要的字节数。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     m 参数为 null。
        //
        //   System.ArgumentException:
        //     m 参数不是 System.Reflection.MethodInfo 对象。
        [SecurityCritical]
        public static int NumParamBytes(MethodInfo m);
        //
        // 摘要: 
        //     返回托管类的非托管形式的字段偏移量。
        //
        // 参数: 
        //   t:
        //     指定托管类的值类型或格式化引用类型。必须将 System.Runtime.InteropServices.StructLayoutAttribute
        //     应用于该类。
        //
        //   fieldName:
        //     t 参数中的字段。
        //
        // 返回结果: 
        //     平台调用声明的指定类中 fieldName 参数的偏移量（以字节为单位）。
        //
        // 异常: 
        //   System.ArgumentException:
        //     该类无法作为结构导出，或者字段为非公共字段。从 .NET Framework 2.0 版开始，该字段可以是私有的。
        //
        //   System.ArgumentNullException:
        //     t 参数为 null。
        [SecuritySafeCritical]
        public static IntPtr OffsetOf(Type t, string fieldName);
        //
        // 摘要: 
        //     在不调用方法的情况下执行一次性方法设置任务。
        //
        // 参数: 
        //   m:
        //     要检查的方法。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     m 参数为 null。
        //
        //   System.ArgumentException:
        //     m 参数不是 System.Reflection.MethodInfo 对象。
        [SecurityCritical]
        public static void Prelink(MethodInfo m);
        //
        // 摘要: 
        //     对类上的所有方法执行预链接检查。
        //
        // 参数: 
        //   c:
        //     要检查其方法的类。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     c 参数为 null。
        [SecurityCritical]
        public static void PrelinkAll(Type c);
        //
        // 摘要: 
        //     将非托管 ANSI 字符串中第一个 null 字符之前的所有字符复制到托管 System.String，并将每个 ANSI 字符扩展为 Unicode
        //     字符。
        //
        // 参数: 
        //   ptr:
        //     非托管字符串第一个字符的地址。
        //
        // 返回结果: 
        //     一个托管字符串，包含非托管 ANSI 字符串的副本。如果 ptr 为 null，则该方法返回空字符串。
        [SecurityCritical]
        public static string PtrToStringAnsi(IntPtr ptr);
        //
        // 摘要: 
        //     分配托管 System.String，然后从非托管 ANSI 字符串向其复制指定数目的字符，并将每个 ANSI 字符扩展为 Unicode 字符。
        //
        // 参数: 
        //   ptr:
        //     非托管字符串第一个字符的地址。
        //
        //   len:
        //     要复制的输入字符串的字节数。
        //
        // 返回结果: 
        //     如果 ptr 参数的值不是 null，则为包含本机 ANSI 字符串副本的托管字符串；否则，此方法返回 null。
        //
        // 异常: 
        //   System.ArgumentException:
        //     len 小于零。
        [SecurityCritical]
        public static string PtrToStringAnsi(IntPtr ptr, int len);
        //
        // 摘要: 
        //     分配托管 System.String，并从非托管内存中存储的字符串向其复制第一个空字符之前的所有字符。
        //
        // 参数: 
        //   ptr:
        //     对于 Unicode 平台，表示第一个 Unicode 字符的地址。- 或 -对于 ANSI 平台，表示第一个 ANSI 字符的地址。
        //
        // 返回结果: 
        //     如果 ptr 参数的值不是 null，则为包含非托管字符串副本的托管字符串；否则，此方法返回 null。
        [SecurityCritical]
        public static string PtrToStringAuto(IntPtr ptr);
        //
        // 摘要: 
        //     分配托管 System.String，并从存储在非托管内存中的字符串向其复制指定数目的字符。
        //
        // 参数: 
        //   ptr:
        //     对于 Unicode 平台，表示第一个 Unicode 字符的地址。- 或 -对于 ANSI 平台，表示第一个 ANSI 字符的地址。
        //
        //   len:
        //     要复制的字符数。
        //
        // 返回结果: 
        //     如果 ptr 参数的值不是 null，则为包含本机字符串副本的托管字符串；否则，此方法返回 null。
        //
        // 异常: 
        //   System.ArgumentException:
        //     len 小于零。
        [SecurityCritical]
        public static string PtrToStringAuto(IntPtr ptr, int len);
        //
        // 摘要: 
        //     分配托管 System.String，并向其复制存储在非托管内存中的 BSTR 字符串。
        //
        // 参数: 
        //   ptr:
        //     非托管字符串第一个字符的地址。
        //
        // 返回结果: 
        //     如果 ptr 参数的值不是 null，则为包含非托管字符串副本的托管字符串；否则，此方法返回 null。
        [SecurityCritical]
        public static string PtrToStringBSTR(IntPtr ptr);
        //
        // 摘要: 
        //     分配托管 System.String，并从非托管 Unicode 字符串向其复制第一个空字符之前的所有字符。
        //
        // 参数: 
        //   ptr:
        //     非托管字符串第一个字符的地址。
        //
        // 返回结果: 
        //     如果 ptr 参数的值不是 null，则为包含非托管字符串副本的托管字符串；否则，此方法返回 null。
        [SecurityCritical]
        public static string PtrToStringUni(IntPtr ptr);
        //
        // 摘要: 
        //     分配托管 System.String，并从非托管 Unicode 字符串向其复制指定数目的字符。
        //
        // 参数: 
        //   ptr:
        //     非托管字符串第一个字符的地址。
        //
        //   len:
        //     要复制的 Unicode 字符数。
        //
        // 返回结果: 
        //     如果 ptr 参数的值不是 null，则为包含非托管字符串副本的托管字符串；否则，此方法返回 null。
        [SecurityCritical]
        public static string PtrToStringUni(IntPtr ptr, int len);
        //
        // 摘要: 
        //     将数据从非托管内存块封送到托管对象。
        //
        // 参数: 
        //   ptr:
        //     指向非托管内存块的指针。
        //
        //   structure:
        //     将数据复制到其中的对象。这必须是格式化类的实例。
        //
        // 异常: 
        //   System.ArgumentException:
        //     结构布局不是连续或显式的。- 或 -结构为装箱的值类型。
        [ComVisible(true)]
        [SecurityCritical]
        public static void PtrToStructure(IntPtr ptr, object structure);
        //
        // 摘要: 
        //     将数据从非托管内存块封送到新分配的指定类型的托管对象。
        //
        // 参数: 
        //   ptr:
        //     指向非托管内存块的指针。
        //
        //   structureType:
        //     待创建对象的类型。此对象必须表示格式化类或结构。
        //
        // 返回结果: 
        //     一个托管对象，包含 ptr 参数指向的数据。
        //
        // 异常: 
        //   System.ArgumentException:
        //     structureType 参数布局不是连续或显式的。- 或 -structureType 参数是泛型类型。
        //
        //   System.ArgumentNullException:
        //     structureType 为 null。
        [ComVisible(true)]
        [SecurityCritical]
        public static object PtrToStructure(IntPtr ptr, Type structureType);
        //
        // 摘要: 
        //     从 COM 对象请求指向指定接口的指针。
        //
        // 参数: 
        //   pUnk:
        //     要查询的接口。
        //
        //   iid:
        //     所请求的接口的接口标识符 (IID)。
        //
        //   ppv:
        //     此方法返回时，包含对返回接口的引用。
        //
        // 返回结果: 
        //     一个 HRESULT，指示调用成功还是失败。
        [SecurityCritical]
        public static int QueryInterface(IntPtr pUnk, ref Guid iid, out IntPtr ppv);
        //
        // 摘要: 
        //     从非托管内存读取单个字节。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的地址。
        //
        // 返回结果: 
        //     从非托管内存读取的字节。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static byte ReadByte(IntPtr ptr);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量（或索引）读取单个字节。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的字节。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static byte ReadByte(IntPtr ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量（或索引）读取单个字节。
        //
        // 参数: 
        //   ptr:
        //     源对象的非托管内存中的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的字节。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static byte ReadByte(object ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存中读取一个 16 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的地址。
        //
        // 返回结果: 
        //     从非托管内存中读取的 16 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static short ReadInt16(IntPtr ptr);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取一个 16 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的 16 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static short ReadInt16(IntPtr ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取一个 16 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     源对象的非托管内存中的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的 16 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static short ReadInt16(object ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存中读取一个 32 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的地址。
        //
        // 返回结果: 
        //     从非托管内存中读取的 32 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static int ReadInt32(IntPtr ptr);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取一个 32 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存中读取的 32 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static int ReadInt32(IntPtr ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取一个 32 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     源对象的非托管内存中的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的 32 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static int ReadInt32(object ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存中读取一个 64 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的地址。
        //
        // 返回结果: 
        //     从非托管内存中读取的 64 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static long ReadInt64(IntPtr ptr);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取一个 64 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的 64 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static long ReadInt64(IntPtr ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取一个 64 位带符号整数。
        //
        // 参数: 
        //   ptr:
        //     源对象的非托管内存中的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的 64 位带符号整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static long ReadInt64(object ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存中读取处理器本机大小的整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的地址。
        //
        // 返回结果: 
        //     从非托管内存读取的整数。在 32 位计算机上返回 32 位整数，在 64 位计算机上返回 64 位整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static IntPtr ReadIntPtr(IntPtr ptr);
        //
        // 摘要: 
        //     从非托管内存按给定的偏移量读取处理器本机大小的整数。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中开始读取的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
        //
        // 摘要: 
        //     从非托管内存中读取处理器本机大小的整数。
        //
        // 参数: 
        //   ptr:
        //     源对象的非托管内存中的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在读取前添加到 ptr 参数中。
        //
        // 返回结果: 
        //     从非托管内存按给定的偏移量读取的整数。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static IntPtr ReadIntPtr(object ptr, int ofs);
        //
        // 摘要: 
        //     调整以前用 System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
        //     分配的内存块的大小。
        //
        // 参数: 
        //   pv:
        //     指向用 System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32) 分配的内存的指针。
        //
        //   cb:
        //     已分配块的新大小。
        //
        // 返回结果: 
        //     一个整数，表示重新分配的内存块的地址。此内存必须用 System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
        //     来释放。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     内存不足，无法满足请求。
        [SecurityCritical]
        public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
        //
        // 摘要: 
        //     调整以前用 System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
        //     分配的内存块的大小。
        //
        // 参数: 
        //   pv:
        //     指向用 System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr) 分配的内存的指针。
        //
        //   cb:
        //     已分配块的新大小。
        //
        // 返回结果: 
        //     指向重新分配的内存的指针。此内存必须用 System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
        //     来释放。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     内存不足，无法满足请求。
        [SecurityCritical]
        public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
        //
        // 摘要: 
        //     递减指定接口上的引用计数。
        //
        // 参数: 
        //   pUnk:
        //     要释放的接口。
        //
        // 返回结果: 
        //     pUnk 参数指定的接口上引用计数的新值。
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        [SecurityCritical]
        public static int Release(IntPtr pUnk);
        //
        // 摘要: 
        //     递减与指定的 COM 对象关联的指定 Runtime Callable Wrapper (RCW) 的引用计数。
        //
        // 参数: 
        //   o:
        //     要释放的 COM 对象。
        //
        // 返回结果: 
        //     与 o 关联的 RCW 的引用计数的新值。此值通常为零，因为无论调用包装 COM 对象的托管客户端有多少，RCW 仅保留对该对象的一次引用。
        //
        // 异常: 
        //   System.ArgumentException:
        //     o 不是一个有效的 COM 对象。- 或 -o 为 null。
        [SecurityCritical]
        public static int ReleaseComObject(object o);
        //
        // 摘要: 
        //     释放线程缓存。
        [Obsolete("This API did not perform any operation and will be removed in future versions of the CLR.", false)]
        [SecurityCritical]
        public static void ReleaseThreadCache();
        //
        // 摘要: 
        //     分配 BSTR 并向其复制托管 System.Security.SecureString 对象的内容。
        //
        // 参数: 
        //   s:
        //     要复制的托管对象。
        //
        // 返回结果: 
        //     非托管内存中将 s 参数复制到的地址；如果提供了 null 对象，则为 0。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     s 参数为 null。
        //
        //   System.NotSupportedException:
        //     当前计算机运行的不是 Microsoft Windows 2000 Service Pack 3 或更高版本。
        //
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr SecureStringToBSTR(SecureString s);
        //
        // 摘要: 
        //     将托管 System.Security.SecureString 对象的内容复制到从非托管 COM 任务分配器分配的内存块。
        //
        // 参数: 
        //   s:
        //     要复制的托管对象。
        //
        // 返回结果: 
        //     非托管内存中将 s 参数复制到的地址；如果提供了 null 对象，则为 0。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     s 参数为 null。
        //
        //   System.NotSupportedException:
        //     当前计算机运行的不是 Microsoft Windows 2000 Service Pack 3 或更高版本。
        //
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
        //
        // 摘要: 
        //     将托管 System.Security.SecureString 对象的内容复制到从非托管 COM 任务分配器分配的内存块。
        //
        // 参数: 
        //   s:
        //     要复制的托管对象。
        //
        // 返回结果: 
        //     非托管内存中将 s 参数复制到的地址；如果提供了 null 对象，则为 0。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     s 参数为 null。
        //
        //   System.NotSupportedException:
        //     当前计算机运行的不是 Microsoft Windows 2000 Service Pack 3 或更高版本。
        //
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
        //
        // 摘要: 
        //     将托管 System.Security.SecureString 的内容复制到非托管内存，并在复制时转换为 ANSI 格式。
        //
        // 参数: 
        //   s:
        //     要复制的托管对象。
        //
        // 返回结果: 
        //     非托管内存中将 s 参数复制到的地址，如果提供了 null 对象，则为 0。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     s 参数为 null。
        //
        //   System.NotSupportedException:
        //     当前计算机运行的不是 Microsoft Windows 2000 Service Pack 3 或更高版本。
        //
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
        //
        // 摘要: 
        //     向非托管内存复制托管 System.Security.SecureString 的内容。
        //
        // 参数: 
        //   s:
        //     要复制的托管对象。
        //
        // 返回结果: 
        //     非托管内存中将 s 参数复制到的地址，如果提供了 null 对象，则为 0。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     s 参数为 null。
        //
        //   System.NotSupportedException:
        //     当前计算机运行的不是 Microsoft Windows 2000 Service Pack 3 或更高版本。
        //
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
        //
        // 摘要: 
        //     设置由指定 COM 对象中的指定键引用的数据。
        //
        // 参数: 
        //   obj:
        //     用于存储数据的 COM 对象。
        //
        //   key:
        //     用于存储数据的 COM 对象的内部哈希表中的键。
        //
        //   data:
        //     要设置的数据。
        //
        // 返回结果: 
        //     如果数据设置成功，则为 true；否则为 false。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     obj 为 null。- 或 -key 为 null。
        //
        //   System.ArgumentException:
        //     obj 不是一个 COM 对象。
        [SecurityCritical]
        public static bool SetComObjectData(object obj, object key, object data);
        //
        // 摘要: 
        //     返回对象的非托管大小（以字节为单位）。
        //
        // 参数: 
        //   structure:
        //     要返回其大小的对象。
        //
        // 返回结果: 
        //     非托管代码中指定对象的大小。
        //
        // 异常: 
        //   System.ArgumentNullException:
        //     structure 参数为 null。
        [ComVisible(true)]
        public static int SizeOf(object structure);
        //
        // 摘要: 
        //     返回非托管类型的大小（以字节为单位）。
        //
        // 参数: 
        //   t:
        //     要返回其大小的类型。
        //
        // 返回结果: 
        //     非托管代码中指定类型的大小。
        //
        // 异常: 
        //   System.ArgumentException:
        //     t 参数是泛型类型。
        //
        //   System.ArgumentNullException:
        //     t 参数为 null。
        public static int SizeOf(Type t);
        //
        // 摘要: 
        //     分配 BSTR 并向其复制托管 System.String 的内容。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     指向 BSTR 的非托管指针；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        //
        //   System.ArgumentOutOfRangeException:
        //     s 的长度超出范围。
        [SecurityCritical]
        public static IntPtr StringToBSTR(string s);
        //
        // 摘要: 
        //     将托管 System.String 的内容复制到从非托管 COM 任务分配器分配的内存块。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     一个整数，表示指向为字符串分配的内存块的指针；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        //
        //   System.ArgumentOutOfRangeException:
        //     s 参数超过了操作系统所允许的最大长度。
        [SecurityCritical]
        public static IntPtr StringToCoTaskMemAnsi(string s);
        //
        // 摘要: 
        //     将托管 System.String 的内容复制到从非托管 COM 任务分配器分配的内存块。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     已分配的内存块；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        //
        //   System.ArgumentOutOfRangeException:
        //     s 的长度超出范围。
        [SecurityCritical]
        public static IntPtr StringToCoTaskMemAuto(string s);
        //
        // 摘要: 
        //     将托管 System.String 的内容复制到从非托管 COM 任务分配器分配的内存块。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     一个整数，表示指向为字符串分配的内存块的指针；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.ArgumentOutOfRangeException:
        //     s 参数超过了操作系统所允许的最大长度。
        //
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr StringToCoTaskMemUni(string s);
        //
        // 摘要: 
        //     将托管 System.String 的内容复制到非托管内存，并在复制时转换为 ANSI 格式。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     非托管内存中将 s 复制到的地址；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        //
        //   System.ArgumentOutOfRangeException:
        //     s 参数超过了操作系统所允许的最大长度。
        [SecurityCritical]
        public static IntPtr StringToHGlobalAnsi(string s);
        //
        // 摘要: 
        //     向非托管内存复制托管 System.String 的内容，并在需要时转换为 ANSI 格式。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     非托管内存中将字符串复制到的地址；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     没有足够的可用内存。
        [SecurityCritical]
        public static IntPtr StringToHGlobalAuto(string s);
        //
        // 摘要: 
        //     向非托管内存复制托管 System.String 的内容。
        //
        // 参数: 
        //   s:
        //     要复制的托管字符串。
        //
        // 返回结果: 
        //     非托管内存中将 s 复制到的地址；如果 s 为 null，则为 0。
        //
        // 异常: 
        //   System.OutOfMemoryException:
        //     此方法未能分配足够的本机堆内存。
        //
        //   System.ArgumentOutOfRangeException:
        //     s 参数超过了操作系统所允许的最大长度。
        [SecurityCritical]
        public static IntPtr StringToHGlobalUni(string s);
        //
        // 摘要: 
        //     将数据从托管对象封送到非托管内存块。
        //
        // 参数: 
        //   structure:
        //     托管对象，包含要封送的数据。该对象必须是格式化类的实例。
        //
        //   ptr:
        //     指向非托管内存块的指针，必须在调用此方法之前分配该指针。
        //
        //   fDeleteOld:
        //     设置为 true 可在执行 System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
        //     方法前对 ptr 参数调用此方法。请注意，传递 false 可导致内存泄漏。
        //
        // 异常: 
        //   System.ArgumentException:
        //     structure 参数是泛型类型。
        [ComVisible(true)]
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        [SecurityCritical]
        public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
        //
        // 摘要: 
        //     用特定的失败 HRESULT 值引发异常。
        //
        // 参数: 
        //   errorCode:
        //     与所需异常相对应的 HRESULT。
        [SecurityCritical]
        public static void ThrowExceptionForHR(int errorCode);
        //
        // 摘要: 
        //     基于指定的 IErrorInfo Interface 接口，以特定的失败 HRESULT 引发异常。
        //
        // 参数: 
        //   errorCode:
        //     与所需异常相对应的 HRESULT。
        //
        //   errorInfo:
        //     指向 COM 对象所提供的 IErrorInfo Interface 接口的指针。
        [SecurityCritical]
        public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
        //
        // 摘要: 
        //     获取指定数组中指定索引处的元素的地址。
        //
        // 参数: 
        //   arr:
        //     包含所需元素的数组。
        //
        //   index:
        //     所需元素的 arr 参数中的索引。
        //
        // 返回结果: 
        //     arr 内的 index 的地址。
        [SecurityCritical]
        public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
        //
        // 摘要: 
        //     将单个字节值写入到非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的地址。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static void WriteByte(IntPtr ptr, byte val);
        //
        // 摘要: 
        //     将单字节值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static void WriteByte(IntPtr ptr, int ofs, byte val);
        //
        // 摘要: 
        //     将单字节值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中目标对象的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static void WriteByte(object ptr, int ofs, byte val);
        //
        // 摘要: 
        //     将一个字符作为 16 位整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的地址。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static void WriteInt16(IntPtr ptr, char val);
        //
        // 摘要: 
        //     将 16 位整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的地址。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static void WriteInt16(IntPtr ptr, short val);
        //
        // 摘要: 
        //     将 16 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     本机堆中要写入的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static void WriteInt16(IntPtr ptr, int ofs, char val);
        //
        // 摘要: 
        //     将 16 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static void WriteInt16(IntPtr ptr, int ofs, short val);
        //
        // 摘要: 
        //     将 16 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中目标对象的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        public static void WriteInt16(object ptr, int ofs, char val);
        //
        // 摘要: 
        //     将 16 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中目标对象的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static void WriteInt16(object ptr, int ofs, short val);
        //
        // 摘要: 
        //     将 32 位带符号整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的地址。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static void WriteInt32(IntPtr ptr, int val);
        //
        // 摘要: 
        //     将 32 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static void WriteInt32(IntPtr ptr, int ofs, int val);
        //
        // 摘要: 
        //     将 32 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中目标对象的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static void WriteInt32(object ptr, int ofs, int val);
        //
        // 摘要: 
        //     将 64 位带符号整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的地址。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static void WriteInt64(IntPtr ptr, long val);
        //
        // 摘要: 
        //     将 64 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static void WriteInt64(IntPtr ptr, int ofs, long val);
        //
        // 摘要: 
        //     将 64 位带符号整数值写入非托管内存中的指定偏移位置。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中目标对象的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        public extern static void WriteInt64(object ptr, int ofs, long val);
        //
        // 摘要: 
        //     将一个处理器本机大小的整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的地址。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     ptr 不是识别的格式。- 或 -ptr 为 null。- 或 -ptr 无效。
        [SecurityCritical]
        public static void WriteIntPtr(IntPtr ptr, IntPtr val);
        //
        // 摘要: 
        //     按指定的偏移量将一个处理器本机大小的整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中要写入的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        [SecurityCritical]
        public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
        //
        // 摘要: 
        //     将一个处理器本机大小的整数值写入非托管内存。
        //
        // 参数: 
        //   ptr:
        //     非托管内存中目标对象的基址。
        //
        //   ofs:
        //     额外的字节偏移量，在写入前添加到 ptr 参数中。
        //
        //   val:
        //     要写入的值。
        //
        // 异常: 
        //   System.AccessViolationException:
        //     基址 (ptr) 加上偏移字节(ofs) 可产生空或无效地址。
        //
        //   System.ArgumentException:
        //     ptr 是 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset
        //     参数。
        [SecurityCritical]
        public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
        //
        // 摘要: 
        //     释放 BSTR 指针，该指针是使用 System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)
        //     方法分配的。
        //
        // 参数: 
        //   s:
        //     要释放的 BSTR 的地址。
        [SecurityCritical]
        public static void ZeroFreeBSTR(IntPtr s);
        //
        // 摘要: 
        //     释放非托管字符串指针，该指针是使用 System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)
        //     方法分配的。
        //
        // 参数: 
        //   s:
        //     要释放的非托管字符串的地址。
        [SecurityCritical]
        public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
        //
        // 摘要: 
        //     释放非托管字符串指针，该指针是使用 System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)
        //     方法分配的。
        //
        // 参数: 
        //   s:
        //     要释放的非托管字符串的地址。
        [SecurityCritical]
        public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
        //
        // 摘要: 
        //     释放非托管字符串指针，该指针是使用 System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)
        //     方法分配的。
        //
        // 参数: 
        //   s:
        //     要释放的非托管字符串的地址。
        [SecurityCritical]
        public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
        //
        // 摘要: 
        //     释放非托管字符串指针，该指针是使用 System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)
        //     方法分配的。
        //
        // 参数: 
        //   s:
        //     要释放的非托管字符串的地址。
        [SecurityCritical]
        public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
    }
}
